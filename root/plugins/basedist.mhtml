<%args>
$object
</%args>

<%doc>
This component creates a graph of composition at each base position along a
read for a FASTA or FASTQ file.
</%doc>

<script type="text/javascript">
    $(function() {
        $("#basedist-tabs").tabs();
    });

    $(function() {
        $('.basedistsparkline').sparkline('html', {type: 'bar', barSpacing: 0,
                  barWidth: 1, barColor: '#d00'});
    });
</script>

<div class="sect">
<span class="sect-title undisclosed-title">
  <a href="#">Base distribution graphs</a>
</span>
<div class="sect-content" id="basedist-tabs">
  <ul>
%   for my $graph_name (@graph_names) {
%     my $pipedata = $graphs{$graph_name};
%     if (defined $pipedata) {
    <li><a href="#basedist-tabs-<% $pipedata->pipedata_id() %>">
        <% $graph_name %>
    </a></li>
%     }
%   }
  </ul>
%   for my $graph_name (@graph_names) {
%     my $pipedata = $graphs{$graph_name};
%     if (defined $pipedata) {
  <div id="basedist-tabs-<% $pipedata->pipedata_id() %>">
    <img src='<% $c->uri_for("/plugin/graph/basedist", $pipedata->pipedata_id()) %>'/>
  </div>
%     }
%   }
</div>
</div>

<%init>
use Tie::IxHash;

my $schema = $c->schema();
my $fast_stats_content_type = $schema->find_with_type('Cvterm', 'name', 'fast_stats');
my @pipedatas = $object->pipedatas()->search({
                  content_type => $fast_stats_content_type->cvterm_id(),
                });

tie my %graphs, 'Tie::IxHash';

%graphs = ();

sub get_sparkline_values
{
  my $c = shift;
  my $pipedata = shift;

  my ($counts_ref, $min, $max) =
    SmallRNA::Web::Controller::Plugin::SizeDistGraph::get_pipedata_counts($c->config(), $pipedata);

  my %counts = %$counts_ref;
  my @lengths = (15 .. $max);

  my @total_counts = (0) x @lengths;

  for my $length (@lengths) {
    for my $base (qw(A T C G)) {

      if (defined $counts{$length}{$base}) {
        $total_counts[$length] += $counts{$length}{$base};
      }
    }
  }

  return join ',', @total_counts;
}

my @graph_names = ('Raw sequence reads', 'Reads after trimming',
                   'Non-redundant reads', 'Genome aligned reads');

for my $pipedata (@pipedatas) {
  my @input_pipedatas = $pipedata->generating_pipeprocess()->input_pipedatas();
  if (@input_pipedatas) {
    my $content_type_name = $input_pipedatas[0]->content_type()->name();
    if ($content_type_name eq 'raw_srna_reads' || $content_type_name eq 'raw_genomic_dna_reads') {
      $graphs{'Raw sequence reads'} = $pipedata;
    } else {
      if ($content_type_name eq 'srna_reads'
          || $content_type_name eq 'genomic_dna_tags'
          || $content_type_name eq 'genomic_dna_reads') {
        $graphs{'Reads after trimming'} = $pipedata;
      } else {
        if ($content_type_name eq 'non_redundant_srna_reads'
            || $content_type_name  eq 'non_redundant_genomic_dna_tags'
            || $content_type_name  eq 'non_redundant_genomic_dna_reads') {
          $graphs{'Non-redundant reads'} = $pipedata;
        } else {
          if ($content_type_name eq 'genome_aligned_srna_reads'
              || $content_type_name eq 'genome_aligned_genomic_dna_tags'
              || $content_type_name eq 'genome_aligned_genomic_dna_reads') {
            $graphs{'Genome aligned reads'} = $pipedata;
          }
        }
      }
    }
  }
}
</%init>
